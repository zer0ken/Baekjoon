# 문제 풀이

### 예제 입력 1
```
4 7
6 13
4 8
3 6
5 12
```

### 예제 출력 1
```
14
```

### 상황 파악

예제 입력과 예제 출력을 확인하고 내용을 살펴보자.

무게와 가치가 정해진 물건들이 놓여있다. 하나씩 집어서 확인해보자. 물건의 순서는 상관이 없다.

처음으로 집은 물건 A의 무게는 6, 가치는 13이라고 하자. 지금 배낭은 비어있기 때문에 이 물건을 넣을 수 있다.

두 번째로 물건 B를 집었다. 무게는 4이고 가치는 8이다. 배낭에 B를 넣으려고 하면 총 무게는 10이 되므로 중량 제한인 7을 초과하게 된다. 즉, B는 A와 함께 넣을 수 없는 것이다.

여기까지 왔을 때, B만 넣으면 무게 4에 가치 8인 배낭이 되고, A만 넣으면 무게 6에 가치 13인 배낭이 된다는 건 자명한 사실이다. 또, B만 넣는 것이 무게가 4일 때 가장 가치있는 배낭을 싸는 방법일테고, A만 넣는 것이 무게가 6일 때 가장 가치있는 배낭을 싸는 방법일테다. 다른 물건을 살펴보지 않은 이 시점에서는 말이다.

이걸 효율적으로 자료구조로 나타내려면 어떻게 하면 좋을까? 직관적으로 이걸 알 수 있는 사람이 있는가 하면, 나처럼 아무리 생각해도 방법이 떠오르지 않는 사람도 있을것이다.

### 자료구조

배열을 생각해보자. 배열의 첫 번째 요소는 무게가 1일 때 배낭이 가질 수 있는 가치의 최고값이다. 배열의 두 번째 요소는 무게가 2일 때의 최고 가치이다. 이런 식으로, 배열의 인덱스가 무게, 배열의 값이 해당 무게로 구성할 수 있는 가장 높은 가치인 배열을 사용해 문제를 풀 수 있다.

배열의 길이는 K이면 충분하다. 무게가 K를 넘어갈 때 배낭의 가치는 생각할 필요가 없기 때문이다.

다시 배낭을 비우고, 마치 처음인 것처럼 물건 A를 집어보자. A를 들고 고민하는 시점에 배열의 값은 다음과 같을 것이다.

```
         배열: [ 0, 0, 0, 0, 0, 13, 0 ]
배열의 인덱스:   1  2  3  4  5   6  7
```

즉, 무게 6일때 가능한 배낭의 최고 가치는 13이라는 것이 배열로 표현되고 있다.

이번에는 물건 B를 들고 고민해보자. 이때는 이전에 집어들었던 다른 물건과 지금 들고있는 B를 같이 넣을 수 있는지, 그렇다면 가치가 어떻게 되는지도 고려해야 한다.

B를 이전 물건들과 함께 넣을 수 있을까? 배열을 순회하면서 확인해보자. 

어떤 값은 0이다. 예를 들어, 인덱스가 3인 요소가 0이다. 이는 무게가 3인 물건이 없거나, 그 무게를 만들 수 있는 물건의 조합이 아직 발견되지 않았음을 의미한다.

어떤 값은 0이 아니다. 여기에서는 인덱스 6의 값이 13이다. 그 무게를 만들 수 있는 물건의 조합이 있다는 것이다. 여기에 추가로 새로운 물건 B를 추가한다면 어떨까? 인덱스 6은 이 조합의 무게가 6이라는 의미이므로, B를 추가하면 무게는 10이 된다. 배열의 값이 13이므로 B를 추가하면 총 가치는 21이 된다. 이렇게 우리는 무게 10으로 만들 수 있는 새로운 조합을 발견했다.

만약 배열에 10번 인덱스가 존재한다면, 즉, 10이 무게 제한을 초과하지 않는다면, 가치가 21이라고 해당 인덱스에 저장해야 한다. 이미 해당 인덱스에 저장된 값이 있다면, 그 값과 이 값을 비교해 더 큰 값을 저장하도록 한다.

```
          배열: [ 0, 0, 0, 8, 0, 13, 0 ] ... 21
 배열의 인덱스:   1  2  3  4  5   6  7   ... 10
```

안타깝지만, 10번 인덱스는 존재하지 않으므로, 이 조합의 정보는 저장하지 않는다.

배열의 순회가 끝났다. 기존 조합에 B를 추가하는 조합은 모두 고려한 것이다. 하지만 아직 B 하나만 사용하는 경우는 고려하지 않았다. B의 무게가 4이므로 4번 인덱스의 값이 B의 무게를 넣는다. 이미 무게가 4인 조합이 존재한다면 4번 인덱스의 값이 0이 아닐 것이다. 이 경우에는 B의 가치과 기존 조합의 가치 중 더 큰 것을 저장하도록 한다.

```
          배열: [ 0, 0, 0, 8, 0, 13, 0 ]
 배열의 인덱스:   1  2  3  4  5   6  7
```

이번에는 세 번째 물건 C에 대해 고려해보자. C는 무게가 3이고 가치가 6이다. 배열을 순회해보자.

처음으로 발견한 0이 아닌 요소는 8, 인덱스는 4이다. 이전에 무게 4로 가치 8을 만드는 조합을 발견했고, 이게 무게 4에서는 최선이라는 의미이다. 이 조합에 C를 더할 수 있나?


```
          배열: [ 0, 0, 0, 8, 0, 13, 14 ]
 배열의 인덱스:   1  2  3  4  5   6   7
```

더할 수 있었다. 배낭의 무게 제한은 7이고, 무게 4인 조합에 C를 더하면 무게가 딱 7이 된다. 이 때의 가치는 14이고, 이것이 배열의 7번 인덱스에 저장됐다. 순회를 계속 하자.

이번에는 6번 인덱스에서 가치 13인 조합이 발견됐다. C를 더해볼까?

```
          배열: [ 0, 0, 0, 8, 0, 13, 14 ] ... 19
 배열의 인덱스:   1  2  3  4  5   6   7   ...  9
```

무게 제한을 초과하므로 무게 6인 조합에 C를 더한 새로운 조합은 사용할 수 없었다. 순회를 계속 하려고 했지만, 여기서 문제가 생겼다. 7번 인덱스의 값에는 이미 C가 포함되어있지 않은가!

중복이 발생했다. C를 넣을지 말지 결정하는 순회에서, C 정보가 이미 포함된 요소를 다시 고려하게 된건 명백한 사고다. 하지만 걱정하지 마라. 간단하게 해결할 수 있다.

앞으로는 순회를 뒤에서부터, 즉 무거운 조합 순으로 방문하면 된다! 기존 조합에 새 물건을 더하면, 무게는 항상 증가한다. 그러므로 새 조합의 정보를 배열에 저장할 때 갱신되는 인덱스는 이미 지나온 인덱스이다! 

예를 들어, 7번 인덱스부터 6, 5, 4번 인덱스를 순서대로 보다가, 무게가 4인 기존 조합에 C를 더한 새 조합을 갱신한다고 하면, 바뀌는 값의 인덱스는 7이고, 이미 지나온 인덱스이다.

### 정말 이 방법이 맞나?

이 방법으로 문제가 풀리는지 손으로 풀어보자.

```
===
A - 무게 6, 가치 13

무게:   1  2  3  4  5   6  7
배열: [ 0, 0, 0, 0, 0, 13, 0 ]

>>> 무게 6에 A가 저장되었다.

===
B - 무게 4, 가치 8

무게:   1  2  3  4  5   6  7   ... 10
배열: [ 0, 0, 0, 8, 0, 13, 0 ] ... 21

>>> 무게 10인 새 조합이 기각되었다.

>>> 무게 4에 B가 저장되었다.

===
C - 무게 3, 가치 6

무게:   1  2  3  4  5   6   7   ... 10  9
배열: [ 0, 0, 6, 8, 0, 13, 14 ] ... 20 19

>>> 무게 10인 새 조합이 기각되었다.
>>> 무게 9인 새 조합이 기각되었다.
>>> 무게 7인 새 조합이 저장되었다.

>>> 무게 3에 C가 저장되었다.

===
D - 무게 5, 가치 12

무게:   1  2  3  4  5   6   7   ... 12 11  9  8
배열: [ 0, 0, 6, 8, 0, 13, 14 ] ... 26 25 20 18

>>> 무게 12인 새 조합이 기각되었다.
>>> 무게 11인 새 조합이 기각되었다.
>>> 무게 9인 새 조합이 기각되었다.
>>> 무게 3인 새 조합이 기각되었다.

>>> 무게 5에 D가 저장되었다.
```

모든 물건에 대해 배열의 순회가 끝났다. 여기서 배낭의 가치가 최대가 되는 경우는 무게 7인 조합을 골랐을 때이다. 배열의 최대값을 확인하면 쉽게 알 수 있다.

만약 여기에 무게가 3이고 가치가 11인 새 물건 E가 추가된다면 어떨까?

```
===
D - 무게 3, 가치 10

무게:   1  2  3   4  5   6   7   ... 10  9  
배열: [ 0, 0, 10, 8, 0, 16, 18 ] ... 24 23 

>>> 무게 10인 새 조합이 기각되었다.
>>> 무게 9인 새 조합이 기각되었다.
>>> 무게 7인 새 조합이 저장되었다.
>>> 무게 6인 새 조합이 저장되었다.

>>> 무게 3에 D가 저장되었다.
```

기존 조합보다 무게 대비 가치가 늘어난 인덱스가 있다. 이런 식으로, 해당 무게로 조합할 수 있는 가장 높은 가치만 배열에 남기는 데에 성공했다.
